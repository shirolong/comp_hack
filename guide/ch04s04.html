<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Object Generator (objgen)</title><link rel="stylesheet" type="text/css" href="static/docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="COMP_hack: The Definitive Guide" /><link rel="up" href="ch04.html" title="Chapter 4. Hacker's Guide" /><link rel="prev" href="ch04s03.html" title="Architecture Overview" /><link rel="next" href="ch04s05.html" title="Release Process" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Object Generator (objgen)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s03.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Hacker's Guide</th><td width="20%" align="right"> <a accesskey="n" href="ch04s05.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46852518903552"></a>Object Generator (objgen)</h2></div></div></div><p>The objgen utility takes XML files as input. These XML files describe the data structures that should be generated. What follows is the format of this XML and examples of how to use the generated code. All XML elements are enclosed in the following:</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;objgen&gt;
    &lt;!-- Describe your objects here. --&gt;
&lt;/objgen&gt;
</pre><p>Each object described is converted to a C++ class. You may describe one as follows:</p><pre class="programlisting">
&lt;object name="MyObject"&gt;
    &lt;!-- Describe your member variables here. --&gt;
&lt;/object&gt;
</pre><p>The object has several properties that you can change:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>name</strong></span> - Name of the object. This is required.</p></li><li class="listitem"><p><span class="strong"><strong>namespace</strong></span> - Namespace to place the object in (default is "objects")</p></li><li class="listitem"><p><span class="strong"><strong>scriptenabled</strong></span> - Enables generation of squirrel script bindings (default is false)</p></li><li class="listitem"><p><span class="strong"><strong>location</strong></span> - Specifies the database ("lobby" or "world") the object is stored in (default is "lobby")</p></li><li class="listitem"><p><span class="strong"><strong>persistent</strong></span> - Enables generation of database load/save (default is true)</p></li><li class="listitem"><p><span class="strong"><strong>baseobject</strong></span> - Name of the base class or object to inherit from (default is "" which uses libcomp::Object)</p></li><li class="listitem"><p><span class="strong"><strong>inherited-construction</strong></span> - When set this will generated a method function called InheritedConstructon that takes the object name. This is used by the XML loading for a list of base objects. For example if you have a list of Action objects but you specify list elements as ActionSetNPCState or ActionAddRemoveStatus it will construct the proper action before storing in the list. (default is false)</p></li></ul></div><p>At a minimum each member variable has a type and a name:</p><pre class="programlisting">
&lt;member type="u8" name="MyVariable"/&gt;
</pre><p>Here is the list of valid types:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>bit, bool, flag</strong></span> - these are boolean types</p></li><li class="listitem"><p><span class="strong"><strong>u8</strong></span> - unsigned 8-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>u16</strong></span> - unsigned 16-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>u32</strong></span> - unsigned 32-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>u64</strong></span> - unsigned 64-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>s8</strong></span> - signed 8-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>s16</strong></span> - signed 16-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>s32</strong></span> - signed 32-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>s64</strong></span> - signed 64-bit integer</p></li><li class="listitem"><p><span class="strong"><strong>f32, float, single</strong></span> - 32-bit single precision floating point</p></li><li class="listitem"><p><span class="strong"><strong>f64, double</strong></span> - 64-bit double precision floating point</p></li><li class="listitem"><p><span class="strong"><strong>enum</strong></span> - enumeration</p></li><li class="listitem"><p><span class="strong"><strong>string</strong></span> - a text string</p></li><li class="listitem"><p><span class="strong"><strong>ref, pref</strong></span> - reference to an object or persistent object (this isn't stored on disk / XML as that doesn't make sense)</p></li></ul></div><p>In addition to these types you may use the name of an object followed by * for a ref/pref to that specific object type.</p><p>Here is the common properties for all variables:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>caps</strong></span> - this will make the name appear in capital letters instead of camel case when generating the API. This is only useful if you variable names start with a lower-case letter.</p></li><li class="listitem"><p><span class="strong"><strong>default</strong></span> - the default value for the member variable when the object is created (default depends on the type - usually blank, false or 0)</p></li><li class="listitem"><p><span class="strong"><strong>inherited</strong></span> - This will not re-create the variable in a child class but can be used to override settings like a default value (default is false.</p></li><li class="listitem"><p><span class="strong"><strong>key</strong></span> - generate a LoadXByKey function for this member variable</p></li><li class="listitem"><p><span class="strong"><strong>unique</strong></span> - generate a LoadXListByKey instead if this is false (default is true)</p></li><li class="listitem"><p><span class="strong"><strong>padding</strong></span> - This will read or write the given number of zero bytes after the member function when loading and saving to a binary format (default is 0)</p></li></ul></div><p>Integer and floating point types has the following additional properties:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>min</strong></span> - Minimum value allowed (default is the min of the numeric type)</p></li><li class="listitem"><p><span class="strong"><strong>max</strong></span> - Maximum value allowed (default is the max of the numeric type)</p></li></ul></div><p>A reference can have the following additional properties:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>nulldefault</strong></span> - The default value for the reference will be null instead of an empty default object (default is false)</p></li></ul></div><p>A string can have the following additional properties:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>empty</strong></span> - Allow an empty string as a valid value (default is true)</p></li><li class="listitem"><p><span class="strong"><strong>regex</strong></span> - Regular expression the string must match or blank for none (default is "")</p></li><li class="listitem"><p><span class="strong"><strong>round</strong></span> - Round the length of the string to 2 or 4 bytes, padding it with zeroes (default is 0)</p></li><li class="listitem"><p><span class="strong"><strong>lensz</strong></span> - Size in bytes of the length integer when saving to binary for a dynamic sized string. Can be 1, 2, or 4 (default is 4).</p></li><li class="listitem"><p><span class="strong"><strong>length</strong></span> - Size in bytes of a fixed length string. Can't be used with lensz or round (default is 0).</p></li><li class="listitem"><p><span class="strong"><strong>encoding</strong></span> - Storage encoding of the string (it's always UTF-8 in memory). Can be utf8, cp932, or cp1252 (default is utf8)</p></li></ul></div><p>An enum can have the following additional properties:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="strong"><strong>underlying</strong></span> - integer type that is used to store the enumeration</p></li></ul></div><p>An array must specify the number of elements allowed with the "size" property. Here is an example:</p><pre class="programlisting">
&lt;member type="array" name="EquippedItems" size="15"&gt;
    &lt;element type="Item*"/&gt;
&lt;/member&gt;
</pre><p>Here is an example of a list (dynamic array):</p><pre class="programlisting">
&lt;member type="list" name="StatusEffects"&gt;
    &lt;element type="StatusEffect*"/&gt;
&lt;/member&gt;
</pre><p>Here is an example of a set (a set is a list that has unique elements):</p><pre class="programlisting">
&lt;member type="set" name="LearnedSkills"&gt;
    &lt;element type="u32"/&gt;
&lt;/member&gt;
</pre><p>Here is an example of a map (associative array):</p><pre class="programlisting">
&lt;member type="map" name="Materials"&gt;
    &lt;key type="u32"/&gt;
    &lt;value type="u16"/&gt;
&lt;/member&gt;
</pre><p>Note that for a set or map you must use an integer or string type for the element or key type.</p><p>Objects are generated using the OBJGEN_XML CMake macro. This macro generates code using objgen. The arguments must start with the name of the output variable that will be passed to the ADD_EXECUTABLE command to ensure the generated files are compiled and linked to the application or library. The 2nd argument must be the main xml schema file that includes all other schema files and structures that code will be generated for. The remaining arguments will change depending on the extension (or lack of one). Files with the xml extension will be used as dependencies to the master xml schema. These are xml schema files that have been declared in an <code class="code">&lt;include&gt;</code> element. Files that end in cpp or h are source files that will be generated. Only the source files defined will be generated despite what structures may be included in the xml schema. Finally, all other arguments are assumed to be a search path for other xml schema files that have be listed in an <code class="code">&lt;include&gt;</code> element.</p><p>You can instead run the command on you own:</p><pre class="programlisting">
comp_objgen -I dir1 -I dir2 -o somefile.h -o somefile.cpp schema.xml moreschema.xml
</pre><p>Here <code class="code">-I</code> is an include directory for XML schema and <code class="code">-o</code> specifies an output file. You can specify multiple include directories, output files and XML schema files on a single command line.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Architecture Overview </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Release Process</td></tr></table></div></body></html>